import json
import queue
import threading
import time
import uuid
from collections.abc import Iterator
from pathlib import Path

from flask import Flask, Response, jsonify, render_template, request

app = Flask(__name__)

BASE_DOWNLOAD_DIR = Path("downloads")
BASE_DOWNLOAD_DIR.mkdir(exist_ok=True)

jobs: dict[str, queue.Queue] = {}


@app.route("/")
def index() -> str:
    return render_template("index.html")


def _emit(q: "queue.Queue[dict | None]", payload: dict | None) -> None:
    q.put(payload)


def _simulate_file_write(target_path: Path, contents: str) -> None:
    target_path.parent.mkdir(parents=True, exist_ok=True)
    target_path.write_text(contents, encoding="utf-8")


def _process_job(job_id: str, mode: str, files: list[str], args: dict[str, str]) -> None:
    q = jobs.get(job_id)
    if q is None:
        return

    base_dir = BASE_DOWNLOAD_DIR / mode
    base_dir.mkdir(parents=True, exist_ok=True)

    meta_description = "\n".join(
        f"{key}: {value}" for key, value in args.items() if str(value).strip()
    )
    valid_files = [name.strip() for name in files if str(name).strip()]

    for index, file_name in enumerate(valid_files, start=1):
        target_path = base_dir / file_name
        _emit(q, {
            "event": "start_file",
            "file": file_name,
            "directory": str(base_dir),
            "index": index,
            "total": len(valid_files),
        })

        for step in range(1, 6):
            time.sleep(0.35)
            _emit(q, {
                "event": "progress",
                "file": file_name,
                "progress": step / 5,
            })

        payload = f"Generated by mtblol downloader\nMode: {mode}\n{meta_description}\nFile: {file_name}\n"
        _simulate_file_write(target_path, payload)

        _emit(q, {
            "event": "file_complete",
            "file": file_name,
            "path": str(target_path),
        })

    _emit(q, {"event": "job_complete", "mode": mode})
    _emit(q, None)


@app.route("/download", methods=["POST"])
def download() -> tuple[Response, int] | Response:
    payload = request.get_json(force=True, silent=True) or {}
    mode = payload.get("mode")
    if mode not in {"input", "output"}:
        return jsonify({"error": "mode must be 'input' or 'output'"}), 400

    files = payload.get("files") or []
    if not isinstance(files, list):
        return jsonify({"error": "files must be an array"}), 400

    args = payload.get("args") or {}
    if not isinstance(args, dict):
        return jsonify({"error": "args must be an object"}), 400

    job_id = uuid.uuid4().hex
    job_queue: "queue.Queue[dict | None]" = queue.Queue()
    jobs[job_id] = job_queue

    thread = threading.Thread(target=_process_job, args=(job_id, mode, files, args), daemon=True)
    thread.start()

    return jsonify({"job_id": job_id})


@app.route("/download/stream/<job_id>")
def stream(job_id: str) -> Response:
    q = jobs.get(job_id)
    if q is None:
        return Response("", status=404)

    def event_stream() -> Iterator[str]:
        while True:
            item = q.get()
            if item is None:
                break
            data = json.dumps(item)
            yield f"data: {data}\n\n"
        jobs.pop(job_id, None)

    headers = {
        "Cache-Control": "no-cache",
        "X-Accel-Buffering": "no",
    }
    return Response(event_stream(), mimetype="text/event-stream", headers=headers)


if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)
